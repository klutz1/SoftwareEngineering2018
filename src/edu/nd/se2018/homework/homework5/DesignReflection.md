Design Reflection -- Homework 5
In order to create the second railroad, I modified the part of the design that controlled when to open and close the gate. I added the second railroad track and second train in the same way that the first train and railroad track were added to the design, but I also changed how the gates were updated by the location of each of the trains. Now, if the current location of either train falls within "range" of either gate, the gates will close. The gates will open again when both trains are out of range (this is done in CrossingGate.java). The moveWesttoEast() function moves the second train in the opposite direction of the first train. At this point, I have not made any substantial tradeoffs in the design because both trains behave in the same way, and both gates observe both trains.

The second part of the design required more independent design decisions. In the AnimationTimer in Simulation.java, a function is called there: changeMovements(). For every road that exists in this "world", the function changeTrainMovement() is called. changeTrainMovement() was placed in the CarFactory class because this is where cars are built and where the new vectors of cars were created. Each road has a vector of cars (roadOneCars and roadTwoCars). A car is added to the vector when it is "built" in buildCar() and removed from the vector in removeOffScreenCars(). The purpose of these vectors is to create a notion of the cars that are currently on the street and makes it easier to change the cars that are observed by other cars. Each Car object now has a boolean attribute that sets it as a "leftMover", or a car that can turn left on the T-junction. This functionality is randomly set when the car is created in buildCar(). The most important function in this functionality is the new function changeTrainMovement(). This function checks each car's left-moving capability and current location. If it is at the point where it can cross the T-junction, the car behind it begins observing the car in front of it. The car starts moving left via the canMoveLeft boolean in the Car class similar to the canMoveVertical boolean. Overall, I liked each of the design decisions because it altered the original design as minimally as possible and correctly implemented the state and observer pattern based on updated changes. Although I could have chosen a more advantageous data structure for adjusting observable cars, vectors proved to be an acceptable way of keeping track of which cars were on a given road at a time.

This design, as-is, certain aspects would scale up well and other parts would not. Specifically, it would be easy to add more tracks, trains, and roads, and it would be easy to change speeds of cars, stopping distances between cars, and the time it takes for a gate to open and close. However, a few significant elements would not scale up well at all: direction & movement of the trains/cars, and adding intersecting roads. The current design works well for horizontal and vertical movement to make decisions, but it would take quite a long time to add roads that intersected diagonally or train tracks that crossed instead of running parallel. How would a car know when to stop if it is traveling at an angle to the gate rather than face-on? For these reasons, it is likely that this design would not scale to a level that is acceptable for the city of South Bend.